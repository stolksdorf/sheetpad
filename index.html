<!DOCTYPE html>
<html>
<head>
	<title>sheetpad</title>

	<script src='https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.3/codemirror.min.js'></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.3/codemirror.min.css">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.3/theme/zenburn.min.css">
	<script src='https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.3/mode/javascript/javascript.min.js'></script>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.3/keymap/sublime.min.js'></script>
	<style>:root{
	--yellow:#f0dfaf;
	--purple:#bfbdd0;
	--black:#3f3f3f;
	--white:#f0dfaf;
	--green:#7f9f7f;
	--grey:#4f4f4f;
	--orange:#dfaf8f;
	--red:#cc9393;
	--blue:#7cb8bb;
}
html,body{
	font-size:16px;
	height:100%;
	padding:2em;
	margin:0px;
	font-family:monospace;
}
body,h1,h2,h3,h4,h5,h6,p,ol,ul{
	margin:0px;
	padding:0px;
	font-weight:normal;
}
body,input,textarea{
	color:var(--white);
	background-color:var(--black);
}
*{
	box-sizing:border-box;
}
.container{
	width:calc(100% - 60px);
	max-width:85rem;
	margin:0 auto;
}
button{
	font-family:monospace;
	border:1px solid var(--green);
	cursor:pointer;
}
input[type='text']{
	border:1px solid var(--yellow);
	outline:none;
	padding:0.2em 0.3em;
	font-family:monospace;
	border-radius:3px;
}
input[type='text']:focus{
	border-color:var(--green);
}
html,body,.root{
	padding:0px;
	margin:0px;
	height:100vh;
}
body main{
	height:calc(100% - 30px);
}
nav{
	border-bottom:1px solid var(--yellow);
}
.editor{
	height:500px;
}
main{
	display:flex;
}
main .inputs{
	width:25%;
}
main .editor{
	flex-grow:1;
	height:100%;
}
main .outputs{
	width:25%;
}
main .group textarea{
	height:100%;
	width:100%;
}
.CollapseGroup{
	display:flex;
	flex-direction:column;
	height:100%;
	border:1px solid var(--blue);
}
.CollapseGroup .group{
	border:1px solid var(--green);
	flex-grow:0;
	display:flex;
	flex-direction:column;
}
.CollapseGroup .group .content{
	display:none;
	flex-grow:1;
}
.CollapseGroup .group.expanded{
	flex-grow:1;
}
.CollapseGroup .group.expanded .content{
	display:block;
}
.CodeMirror{
	height:100%;
}</style>
	<script>window.css={};</script>
</head>
<body><main></main></body>
<script>
if(typeof window !=='undefined') global=window;
global.__Modules = global.__Modules||{};
(function(){
	global.__Modules["16fkro7"]={func:function(module, exports, global, __filename, __dirname, __root, require){if (!String.prototype.replaceAll) String.prototype.replaceAll = function(str, newStr){ return this.replace(new RegExp(str, 'g'), newStr) };

const weave = (a1, a2)=>a2.reduce((acc,a,idx)=>acc.concat(a1[idx], a),[]).concat(a1[a1.length-1]);
const tag = (input, vals)=>(Array.isArray(input)) ? weave(input, vals).join('') : input;

const picoparse = (rules, text)=>{
	let remaining = text, result = [], skip=false, pos=0;
	while(remaining.length > 0){
		let match = rules.reduce((best, [rgx, fn])=>{
			let match = rgx.exec(remaining);
			if(!match) return best;
			if(!best || match.index < best.index){ match.func = fn; return match; }
			return best;
		}, false);
		if(!match) break;
		const [text, ...groups] = match;
		pos += match.index;
		const res = match.func(groups, {text, pos, pre:remaining.substring(0,match.index)})
		if(typeof res == 'boolean'){ skip = res; }
		else if(!skip && res){ result.push(res); }
		remaining = remaining.substring(match.index + text.length);
	}
	return result;
};

const convertKeys = (keys)=>{
	let media;
	return {
		sel : keys.reduce((acc,key)=>{
			if(key.startsWith('@media')){
				media=key;
				return acc;
			}
			return acc.flatMap(sublist=>key.split(',').map(subkey=>sublist.concat(subkey.trim())))
		},[[]])
			.map(arr=>arr.join(' ').replaceAll(' &', '').replaceAll(' :', ':'))
			.join(','),
		media
	}
};

const parse = (str)=>{
	const parsed = picoparse([
		[/\/\*(\*(?!\/)|[^*])*\*\//, ()=>null],
		[/\s*\/\/.*/,                ()=>null],
		[/([^{};\s][^{};]*){/,       ([selector])=>['selc', selector.trim()]],
		[/([\w+-]+)\s*:\s*([^;]+);/, ([key, val])=>['rule', key, val]],
		[/}/,                        ()=>['close']],
	], str);

	let keys = [];
	return parsed.reduce((acc,[type, key, val])=>{
		if(type=='selc') keys.push(key);
		if(type=='close') keys.pop();
		if(type=='rule'){
			const {sel, media} = convertKeys(keys);
			const last = acc[acc.length-1]||{};
			if(sel!=last.sel || media!=last.media){
				acc.push({sel,media,rules:{}});
			}
			if(val.indexOf('}')!==-1||val.indexOf(':')!==-1) throw new Error(`ERR: CSS parsing error near: ${sel} -> ${key}`);
			acc[acc.length-1].rules[key] = val;
		}
		return acc;
	}, [])
};

const toString = (selectorList)=>{
	return selectorList.map(({sel, media, rules})=>{
		let res = [], buf=media?'\t':'';
		if(media) res.push(media+'{');
		if(sel) res.push(buf+sel+'{');
		Object.entries(rules).map(([k,v])=>res.push(`${buf}\t${k}:${v};`))
		if(sel) res.push(buf+'}');
		if(media) res.push('}');
		return res.join('\n')
	}).join('\n')
}

const css = (input, ...vals)=>toString(parse(tag(input, vals)));

css.parse    = parse;
css.tag      = tag;
css.toString = toString;
css.inject   = (input, ...vals)=>document.head.insertAdjacentHTML('beforeend', `<style>${css(input, ...vals)}</style>`);

module.exports = css;
},deps:{},fn:'../pico-css/pico-css.js',dn:'../pico-css', root:'../sheetpad'};
global.__Modules["10l24bj"]={func:function(module, exports, global, __filename, __dirname, __root, require){const isObj = (obj)=>!!obj && (typeof obj == 'object' && obj.constructor == Object);
const isList = (obj)=>Array.isArray(obj) || isObj(obj);
const exe = (obj,...args)=>typeof obj === 'function' ? obj(...args) : obj;
const undef = (obj)=>typeof obj === 'undefined';
const hash = (str)=>[...str].reduce((acc, char)=>{acc = ((acc<<5)-acc)+char.charCodeAt(0);return acc&acc; }, 0).toString(32);

const isListSame = (a,b)=>{
	if(typeof a === 'undefined' || typeof b === 'undefined') return false;
	if(a===b) return true;
	if(!isList(a)||!isList(b)) return false;
	const A = Object.keys(a), B = Object.keys(b);
	if(A.length !== B.length) return false;
	return A.every(k=>a[k]===b[k]);
};
const weave = (arr, func)=>{
	let res = [];
	arr.map((val, idx)=>{
		if(!!val) res.push(val);
		if(idx != arr.length-1) res.push(func());
	})
	return res;
};

const isServerSide = typeof window === 'undefined';

Archive = (isServerSide ? global : window).Archive || {};

const DP = (typeof DOMParser !== 'undefined') ? new DOMParser() : null;
const PH = String.fromCharCode(7);

let xo = {ver: '0.3.0', debug : true};

xo.parser = (htmlString, id)=>{
	const body = DP.parseFromString(htmlString, 'text/html').body;
	if(body.children.length > 1) throw 'Multiple top level elements were returned in blueprint';
	let dom = body.children[0], slots = [];
	const insertSlots = (el, isOnlyChild)=>{
		const containsPlaceholder = el.nodeName == "#text" && el.nodeValue.indexOf(PH) !== -1;
		if(containsPlaceholder){
			el.replaceWith(...weave(el.nodeValue.trim().split(PH), xo.parser.createPlaceholder));
		}
		Array.from(el.childNodes||[]).map(cn=>insertSlots(cn, el.childNodes.length==1));
	};
	const parseElement = (el, path=[])=>{
		if(el.nodeName == "#text" && el.nodeValue.trim() === PH){
			slots.push({ attr : 'content', path : path.slice(0,-1) });
			el.nodeValue='';
		}
		Array.from(el.attributes||[])
			.map(({name, value})=>{
				if(value.indexOf(PH) == -1) return;
				if(value !== PH) throw `Element attribute '${name}' is overloaded`;
				slots.push({ path, attr: name });
				el.removeAttribute(name);
			});
		Array.from(el.childNodes||[])
			.map((child, idx)=>parseElement(child, path.concat(idx)));
	};
	insertSlots(dom);
	parseElement(dom);
	if(xo.debug && id) dom.setAttribute('data-xo', id);
	return { slots, dom  };
};

xo.parser.extract = (targetEl, path)=>path.reduce((el, idx)=>el.childNodes[idx], targetEl);
xo.parser.replace = (targetEl, node)=>{
	const newNode = node.cloneNode(true);
	targetEl.replaceWith(newNode);
	return newNode;
};
xo.parser.update = (targetEl, attr, data)=>{
	if(attr=='content'){
		if(targetEl.nodeName == '#text'){
			targetEl.nodeValue = (!data&&data!==0) ? '' : data;
		}else{
			targetEl.innerHTML = (!data&&data!==0) ? '' : data;
		}
	}else if(attr=='class'){
		targetEl.classList = data;
	}else if(typeof data === 'boolean'){
		targetEl.toggleAttribute(attr, data);
	}else{
		targetEl[attr] = data;
	}
	return targetEl;
};
xo.parser.createPlaceholder = ()=>{
	const slot = document.createElement('slot');
	slot.innerHTML = PH;
	return slot;
};

///////////////////

xo.x = (strings, ...data)=>{
	const str = Array.isArray(strings) ? strings.join(PH) : strings;
	const key = hash(str);
	if(!Archive[key]){
		Archive[key] = xo.parser(str, key);
		if(Archive[key].slots.length !== data.length){
			throw `Blueprint ${key} has mismatch between data and slots. Probably an HTML issue`;
		}
	}
	return { type: 'bp', data, key, ...Archive[key] };
};
xo.comp = (func)=>{
	const key = hash(func.toString());
	return (...args)=>{ return { type: 'comp', func, args, key }};
};

const getType = (obj)=>{
	if(!obj) return 'data';
	if(obj.type=='bp'||obj.type=='comp'||obj.type=='list'||obj.type=='data') return obj.type;
	if(isList(obj)) return 'list';
	return 'data';
};

const runComponent = (comp, node)=>{
	let stateCounter=0,effectCounter=0;
	node.useState = (init)=>{
		let idx = stateCounter++;
		if(undef(node.states[idx])) node.states[idx] = exe(init);
		return [node.states[idx], (val, force=false)=>{
			return new Promise((resolve, reject)=>{
				if(node.states[idx] === val && !force) return;
				node.states[idx] = val;
				node.reRender(resolve);
				// node.args = undefined;
				// if(!node.throttle){
				// 	node.throttle = setTimeout(()=>{
				// 		node = render(comp, node);
				// 		resolve();
				// 	},0);
				// }
			})
		}];
	};
	node.useEffect=(func, args)=>{

		let idx = effectCounter++;
		if(!node.effects[idx]) node.effects[idx] = {};
		if(!isListSame(args, node.effects[idx].args)){
			exe(node.effects[idx].cleanup);
			node.effects[idx] = { func, args, flag : true };
		}
	}
	//add in useAsync
	node.reRender = (func)=>{
		//console.log('re-render')
		node.args = undefined;
		if(!node.throttle){
			node.throttle = setTimeout(()=>{
				node = render(comp, node);
				func&&func();
			},0);
		}
	}
	node.forceRender = node.rerender;
	return comp.func.apply(node, comp.args);
};

const mount = (obj, node)=>{



	const type = getType(obj);

	//if(type !== 'data')

		//console.log('mounting', obj, node)


	node = { type, el : node.el, attr : node.attr||'content'};
	if(obj && obj.key) node.key = obj.key;  //TODO: needed?

	if(type == 'bp'){
		node.el = xo.parser.replace(node.el, obj.dom);
		node.children = obj.slots.map(({path, attr})=>{
			return { el : xo.parser.extract(node.el, path), attr };
		});
	}
	if(type =='comp'){
		node.effects = []; node.states = []; node.refs = {};
		node.args = undefined;
		node.children = [{el : node.el}]; //TODO:

	}
	if(type=='list'){
		const onlyChildIsSlot = node.el.parentElement.childNodes.length == 1
		if(onlyChildIsSlot){
			node.MUST_REPLACE = true;
			node.el = node.el.parentElement;
			node.el.innerHTML = '';
		}else{
			node.el = xo.parser.replace(node.el, document.createElement('slot'));
		}
		node.children = {};
	}
	if(type=='data'){
		node.val = undefined;
		if(node.attr == 'content'){
			node.el = xo.parser.replace(node.el, document.createTextNode(''));
		}
	}
	return node;
};


const unmount = (node)=>{
	if(!node.type) return node;

	if(node.effects) node.effects.map(({cleanup})=>exe(cleanup));
	if(node.children) Object.values(node.children).map(unmount);

	//TOD: possible re-think
	//if(node.type == 'bp') node.el = xo.parser.replace(node.el, document.createElement('slot'));
	return {el:node.el, attr:node.attr};
};


const render = (obj, node)=>{
	const type = getType(obj);
	if(type !== node.type) node = mount(obj, unmount(node));

	if(type=='data'){
		if(obj !== node.val){
			node.el = xo.parser.update(node.el, node.attr, obj);
			node.val = obj;
		}
	}
	if(type == 'bp'){
		if(obj.key !== node.key) node = mount(obj, unmount(node));
		obj.data.map((val, idx)=>{
			node.children[idx] = render(val, node.children[idx]);
		});
	}
	if(type =='comp'){
		if(obj.key !== node.key) node = mount(obj, unmount(node));
		if(isListSame(obj.args, node.args)) return node;

		node.throttle = false;
		node.args = obj.args;
		node.children[0] = render(runComponent(obj, node), node.children[0]);
		node.el = node.children[0].el;

		node.effects.map((eff, idx)=>{
			if(eff.flag){
				node.effects[idx].flag = false;
				node.effects[idx].cleanup = eff.func();
			}
		});
	}
	if(type=='list'){
		//TODO: re-write using that fast/slow method
		// Check the length, if same, jump to fast
		// if not

		Object.keys(node.children).map(key=>{
			if(!undef(obj[key])) return;
			unmount(node.children[key]);
			node.children[key].el.remove();
			Array.isArray(node.children) ? node.children.splice(key, 1) : delete node.children[key];
		});

		const newItems = Object.entries(obj);
		newItems.map((_item, _idx)=>{
			const reverse_idx = newItems.length - _idx - 1;
			const [key, val] = newItems[reverse_idx];

			const baseItem = node.children[key] || mount(val, {el : document.createElement('slot')});

			obj[key] = render(val, baseItem);

			if(node.el.childNodes[reverse_idx] !== obj[key].el){
				const nextSibling = newItems[reverse_idx + 1];
				const targetEl = nextSibling ? obj[nextSibling[0]].el : null;
				node.el.insertBefore(obj[key].el, targetEl);
			}
		});
		node.children = obj;
	}
	return node;
};

xo.render = (targetEl, obj, tree)=>render(obj, tree || { el : targetEl, attr: 'content' });

/* Utils */

xo.cx = (...args)=>{
	return args.map((arg)=>{
		if(Array.isArray(arg)) return xo.cx(...arg);
		if(isObj(arg)) return Object.entries(arg).filter(([k,v])=>!!v).map(([k,v])=>k).join(' ');
		return arg;
	}).join(' ');
};

xo.keymap = (arr, fn)=>Object.fromEntries(Object.entries(arr).map(([k,v])=>fn(v,k)));


if(isServerSide){
	xo.x = (strings, ...data)=>{return {type:'bp', strings, data}};
	xo.render = (obj)=>{
		if(obj && obj.type=='bp') return obj.strings.reduce((acc,str,idx)=>acc+str+xo.render(obj.data[idx]||''),'');
		if(isList(obj)) return Object.values(obj).map(xo.render).join('\n');
		if(typeof obj == 'function') return '';
		return obj;
	};
	xo.comp = (func)=>{ //FIXME: I don't think this works
		return func.bind({
			useState : (init)=>{return [init,()=>{}]},
			useEffect :(func)=>null,
			refs : {}
		})
	}
}

if(typeof window !== 'undefined') window.xo = xo;
if(typeof module !== 'undefined') module.exports = xo;
},deps:{},fn:'../xo/xo.js',dn:'../xo', root:'../sheetpad'};
global.__Modules["-4gft1c"]={func:function(module, exports, global, __filename, __dirname, __root, require){const css = require('../pico-css');
const xo = require('../xo');
const {comp,x,cx} = xo;


global.css.crux_style = css`
	:root{
		--yellow : #f0dfaf;
		--purple : #bfbdd0;
		--black  : #3f3f3f;
		--white  : #f0dfaf;
		--green  : #7f9f7f;
		--grey   : #4f4f4f;
		--orange : #dfaf8f;
		--red    : #cc9393;
		--blue   : #7cb8bb;
	}
	html,body{
		font-size   : 16px;
		height      : 100%;
		padding     : 2em;
		margin      : 0px;
		font-family : monospace;
	}
	body,h1,h2,h3,h4,h5,h6,p,ol,ul{
		margin      : 0px;
		padding     : 0px;
		font-weight : normal;
	}
	body,input,textarea{
		color            : var(--white);
		background-color : var(--black);
	}
	*{
		box-sizing: border-box;
	}
	.container{
		width     : calc(100% - 60px);
		max-width : 85rem;
		margin    : 0 auto;
	}

	button{
		font-family: monospace;
		border: 1px solid var(--green);
		cursor: pointer;

	}

	input[type='text']{
		border        : 1px solid var(--yellow);
		outline       : none;
		padding       : 0.2em 0.3em;
		font-family   : monospace;
		border-radius : 3px;

		&:focus{
			border-color: var(--green);
		}
	}
`;

module.exports = {
	css : css, //(typeof window !== 'undefined') ? css : ()=>{}
	comp,x,cx,xo
}
},deps:{"../pico-css":"16fkro7","../xo":"10l24bj"},fn:'crux.js',dn:'.', root:''};
global.__Modules["dmhtav"]={func:function(module, exports, global, __filename, __dirname, __root, require){const {css,xo,x,cx,comp} = require('../crux.js');

global.css.collapseGroup = css`
	.CollapseGroup{
		display        : flex;
		flex-direction : column;
		height         : 100%;

		border : 1px solid var(--blue);

		.group{
			border         : 1px solid var(--green);
			flex-grow      : 0;
			display        : flex;
			flex-direction : column;
			.content{
				display   : none;
				flex-grow : 1;
			}

			&.expanded{
				flex-grow : 1;
				.content{
					display : block;
				}
			}
		}

	}
`;



const CollapseGroup = comp(function(groups, initStates={}){
	const [expandedGroups, setExpandedGroups] = this.useState(initStates);

	return x`<div class='CollapseGroup'>
		${xo.keymap(groups, (val, key)=>{
			const expanded = !!expandedGroups[key];

			return [key,
				x`<div class=${cx('group', {expanded})}>
					<h3 onclick=${()=>setExpandedGroups({...expandedGroups, [key]:!expanded})}>${key}</h3>
					<div class='content'>${val}</div>
				</div>`
			]
		})}

	</div>`

});



module.exports = CollapseGroup;
},deps:{"../crux.js":"-4gft1c"},fn:'client/collaspeGroup.js',dn:'client', root:'..'};
global.__Modules["12sg8g2"]={func:function(module, exports, global, __filename, __dirname, __root, require){const {css,xo,x,cx,comp} = require('../crux.js');


global.css.editor = css`
	.CodeMirror{
		height: 100%;
	}
`

const Editor = comp(function(initVal='', onChange=()=>{}, opts={}){
	this.useEffect(()=>{
		this.refs.editor = CodeMirror.fromTextArea(this.el, {
			lineNumbers    : true,
			theme          : 'zenburn',
			indentWithTabs : true,
			mode           : "javascript",
			keyMap         : "sublime",
			...opts
		});
	}, []);
	this.useEffect(()=>{
		if(this.refs.editor.getValue() !== initVal){
			this.refs.editor.setValue(initVal);
		}
	},[initVal]);
	this.useEffect(()=>{
		this.refs.editor.on("change", ()=>{
			onChange(this.refs.editor.getValue())
		});
	},[])

	return x`<textarea></textarea>`
})

module.exports = Editor;
},deps:{"../crux.js":"-4gft1c"},fn:'client/editor.js',dn:'client', root:'..'};
global.__Modules["-1re7ajm"]={func:function(module, exports, global, __filename, __dirname, __root, require){

/*

Function('"use strict";return (' + obj + ')')();

*/


module.exports = (code, ...inputs)=>{
	let logs = [], error, output;



	const console = {
		log : (...args)=>logs.push(args)
	};

	try{
		//output = Function('"use strict";return (' + code + ')')();
		output = eval(`(()=>{
			let input1 = "${inputs[0]}";
			${code}
		})()`);
	}catch(err){
		error = err;
		logs.push(err);
	}

	return {
		output, logs, error
	}
}
},deps:{},fn:'client/worker.js',dn:'client', root:'..'};
global.__Modules["8m2e8t"]={func:function(module, exports, global, __filename, __dirname, __root, require){const {css,xo,x,cx,comp} = require('../crux.js');

const useLocalState = (scope, key, init)=>{
	const [val, setVal] = scope.useState(()=>{
		try{ return JSON.parse(window.localStorage.getItem(key)) ?? init;
		}catch(err){ return init; }
	});
	return [val, (newVal)=>{
		try{ window.localStorage.setItem(key, JSON.stringify(newVal)); } catch (err){}
		setVal(newVal);
	}];
};

global.css.main = css`
	html,body,.root{
		padding: 0px;
		margin:0px;
		height:100vh;
	}
	body{

		nav{

		}
		main{
			height : calc(100% - 30px);
		}
	}
	nav{
		border-bottom: 1px solid var(--yellow);
	}


	.editor{
		height : 500px;
		.CollapseGroup{

		}
	}

	main{
		display: flex;

		.inputs{
			width : 25%;
		}
		.editor{
			flex-grow : 1;
			height: 100%;
		}
		.outputs{
			width : 25%;
		}


		.group{
			textarea{
				height:100%;
				width:100%;
			}
		}


	}

`;

// const json2csv = (data)=>{
// 	let header = Object.keys(data[0]);

// };

// const xsv2json = (xsv)=>{
// 	const delimiter = xsv.indexof('\t')==-1 ? ',' : '\t';
// 	let [header, ...rows] = xsv.split('\n');
// 	header = header.split(delimiter);
// 	return rows.map(row=>{
// 		return row.split(delimiter).reduce((acc, val, idx)=>{
// 			acc[header[idx]] = val;
// 			return acc;
// 		},{})
// 	});
// };



// //const Sheet = comp(function(name, data, onChange){
// const Sheet = comp(function(name){
// 	const [viewMode, setViewMode] = this.useState('edit'); //'table'

// 	const [data, setData] = this.useState('');

// 	const renderSheet = ()=>{
// 		const data = xsv2json(data);

// 	}
// 	const renderEdit = ()=>{

// 		return x`<textarea value=${data} oninput=${(evt)=>setData(evt.target.value)}></textarea>`
// 	}

// 	return x`<div class='Sheet'>
// 		<div class='controls'>
// 			<label>${name}</label>

// 			<i class='fa fa-fw fa-copy'></i>
// 			<i class='fa fa-fw fa-code'></i>
// 			<i class='fa fa-fw fa-table'></i>
// 		</div>

// 		${viewMode == 'edit'
// 			? renderEdit()
// 			: renderSheet()}

// 		${data}
// 	</div>`
// })




const Logs = (logs)=>{

}


const CollapseGroup = require('./collaspeGroup.js');
const Editor = require('./editor.js');

const Worker = require('./worker.js');

const Main = comp(function(){
	const [code, setCode] = useLocalState(this, 'code', `//Let's gooooo\n\n\n\n`);
	const [input1, setInput1] = useLocalState(this, 'input1', '');
	const [input2, setInput2] = useLocalState(this, 'input2', '');
	const [input3, setInput3] = useLocalState(this, 'input3', '');

	const [output, setOutput] = this.useState({
		result : null,
		logs : []
	});

	console.log(output)

	this.useEffect(()=>{

		if(this.refs.debounce) return;

		this.refs.debounce = true;

		setTimeout(()=>{
			console.log('RUNNING')
			setOutput(Worker(code, input1));
			this.refs.debounce = false;
		}, 500)
	}, [code, input1]);

	return x`<div class='root'>
		<nav>
			Sheetpad
		</nav>
		<main>
			<div class='inputs'>
				${CollapseGroup({
					input1 : x`<textarea
						value=${input1}
						oninput=${(evt)=>setInput1(evt.target.value)}></textarea>`,
					input2 : x`<textarea
						value=${input2}
						oninput=${(evt)=>setInput2(evt.target.value)}></textarea>`,
					input3 : x`<textarea
						value=${input3}
						oninput=${(evt)=>setInput3(evt.target.value)}></textarea>`,
				}, { input1 : true })}
			</div>
			<div class='editor'>
				${Editor(code, setCode)}
			</div>
			<div class='outputs'>
				${CollapseGroup({
					result : x`<div>${output.result}</div>`,
					logs : x`<div>BAR</div>`
				}, { result : true, logs : true })}
			</div>
		</main>
	</div>`
});


module.exports = Main;
},deps:{"../crux.js":"-4gft1c","./collaspeGroup.js":"dmhtav","./editor.js":"12sg8g2","./worker.js":"-1re7ajm"},fn:'client/main.js',dn:'client', root:'..'};
	const req = (id)=>{
		const mod = global.__Modules[id];
		if(mod.executed) return mod.export;
		let m = {exports : {}};
		mod.func(m,m.exports,global,mod.fn,mod.dn,mod.root,(reqPath)=>req(mod.deps[reqPath]));
		mod.executed = true;
		mod.export = m.exports;
		return mod.export;
	}
	if(typeof module === 'undefined'){
		global['main'] = req('8m2e8t');
	}else{
		module.exports = req('8m2e8t');
	}
})();</script>
<script>xo.render(document.body.children[0], window.main());</script>
</html>